<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_16255_cmdb_sync.DownloadProcessor</api_name>
        <client_callable>false</client_callable>
        <description>Parses  downloaded XML files and puts data in staging tables.</description>
        <name>DownloadProcessor</name>
        <script><![CDATA[var DownloadProcessor = Class.create();
DownloadProcessor.prototype = {
    initialize: function() {
    },

    type: 'DownloadProcessor',
	
	tables: {
		queue: 'x_16255_cmdb_sync_queue',
		attachment: 'sys_attachment'
	},
	
	xmlDoc: null,
	
	run: function () {
		var queueGr = new GlideRecord(this.tables.queue);
		queueGr.addQuery('status', 'Queued');
		queueGr.addQuery('type', 'Download');
		queueGr.setLimit(1); // pick up only 1 record at a time
		queueGr.orderBy('sys_created_on');
		queueGr.query();
		
		gs.info("No. of records found: " + queueGr.getRowCount());
		
		while (queueGr.next()) {
			var result = this.process(queueGr);
			if (result.successful) {
				queueGr.status = 'Success';
			} else {
				queueGr.status = 'Error';
				queueGr.message = result.message;
			}
			queueGr.update();
		}
	},
	
	/*
	process
	*/
	process: function (queueGr) {
		var result = {
			successful: true,
			message: ''
		};
		
		try {
			// get attachment as stream
			var xmlStream = this.getAttachmentStream(queueGr);
			this.xmlDoc = new XMLDocument2(xmlStream);
			var documentRoot = this.xmlDoc.getDocumentElement();
			
			var responseCode = this.xmlDoc.getNodeText("//assetDetailsResponse/responseCode");
			var assetsCount  = this.xmlDoc.getNodeText("//assetDetailsResponse/count");
			gs.info("responseCode: " + responseCode + " assetsCount: " + assetsCount);
			
			var asset = this.xmlDoc.getFirstNode('//assetDetailsResponse//assetListData/asset') || false;
			while (asset) {
				this.xmlDoc.setCurrentElement(asset);
				
				// get software list
				var softwareList = this.xmlDoc.getNode('//softwareListData');
				var softwareResult = this.processSoftware(softwareList);
				gs.info("Processed " + softwareResult.count + " software entries.");
				
				this.xmlDoc.setCurrentElement(documentRoot);
				// move to next asset.
				asset = this.xmlDoc.getNextNode(asset);
			} // while assetNode
		} catch (error) {
			gs.error(error);
			result.successful = false;
			result.message = error;
		} finally {
			return result;
		}
	},
	
	processSoftware: function (softwareList) {
		gs.info("softwareList node name: " + softwareList.getNodeName());
		
		var returnValue = {
			count: 0,
		};
		try {
			var softwareIterator = softwareList.getChildNodeIterator();

			while (softwareIterator.hasNext()) {
				var software = softwareIterator.next();
				var softwareXml = new XMLDocument2();
				softwareXml.parseXML(software.toString());

				var fullName = softwareXml.getNodeText('//fullName');
				var softwareType = softwareXml.getNodeText('//softwareType');
				var isIgnored = softwareXml.getNodeText('//isIgnored');
				var ignoredReason = softwareXml.getNodeText('//ignoredReason');
				var categoryType = softwareXml.getNodeText('//categoryType');
				var category = softwareXml.getNodeText('//category');
				var category1 = softwareXml.getNodeText('//category1');
				var category2 = softwareXml.getNodeText('//category2');
				var productName = softwareXml.getNodeText('//productName');                
				var component = softwareXml.getNodeText('//component');
				var publisher = softwareXml.getNodeText('//publisher');
/*               <edition />
               <marketVersion />
               <version />
               <update />
               <architecture />
               <installDate />
               <language />
               <lifecycle>
                  <gaDate />
                  <stage />
               </lifecycle>
               <license>
                  <category />
               </license>
*/
				returnValue.count++;
			}			
		} catch (error) {
			gs.error(error);
		} finally {
			return returnValue;
		}
	}, // processSoftware
	
	// TODO: move this function to util
	getAttachmentStream: function (gr) {
		var attachmentGr = new GlideRecord(this.tables.attachment);
		attachmentGr.addQuery('table_name', gr.getTableName());
		attachmentGr.addQuery('table_sys_id', gr.sys_id);
		attachmentGr.query();
		
		var stream = null;
		while (attachmentGr.next()) {
			var sa = new GlideSysAttachment();
			stream = sa.getContentStream(attachmentGr.sys_id.toString());
		}
		
		return stream;
	}, // getAttachmentStream
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2019-05-08 16:02:53</sys_created_on>
        <sys_id>02a39d29db11330011b3e9c948961947</sys_id>
        <sys_mod_count>18</sys_mod_count>
        <sys_name>DownloadProcessor</sys_name>
        <sys_package display_value="Sync App" source="x_16255_cmdb_sync">8b8f5740dbb203009b6cf7fdbf9619b6</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Sync App">8b8f5740dbb203009b6cf7fdbf9619b6</sys_scope>
        <sys_update_name>sys_script_include_02a39d29db11330011b3e9c948961947</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2019-05-08 18:22:53</sys_updated_on>
    </sys_script_include>
</record_update>
